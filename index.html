<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <title>vis_tra</title>

    <meta charset='UTF-8'>
    <title></title>
    <script src="https://d3js.org/d3.v5.js"></script>
    <script type="text/javascript" src="./static/js/taxi_zones.js"></script>
    <link rel="stylesheet" type="text/css" href="./static/css/styles.csss">


  </head>
  <body>
    <div id="app"></div>
    
    <div class="#root">
      <svg class="chart">
          <defs>
              <mask id="Mask0">
                  <circle id="circle0" r="150" fill="url(#grad)"  />
              </mask>
              <mask id="Mask1">
                  <circle id="circle1" r="150" fill="url(#grad)"  />
            </mask>

              <radialGradient
                  id="grad"
                  cx="0.5"
                  cy="0.5"
                  r="0.5" >
                  <stop offset="0%" stop-color="#fff" stop-opacity='1'/>
                  <stop offset="100%" stop-color="#fff" stop-opacity='0' />
              </radialGradient>
          </defs>

          <filter id="inLight" x="-50%" y="-50%" width="200%" height="200%">
              <feComponentTransfer in=SourceAlpha>
                <feFuncA type="table" tableValues="1 0" />
              </feComponentTransfer>
              <feGaussianBlur stdDeviation="4"/>
              <feOffset dx="0" dy="1" result="offsetblur"/>
              <feFlood flood-color="#d9f939" result="color"/>
              <feComposite in2="offsetblur" operator="in"/>
              <feComposite in2="SourceAlpha" operator="in" />
              <feMerge>
                <feMergeNode in="SourceGraphic" />
                <feMergeNode />
              </feMerge>
          </filter>

          <filter id="outLight" x="-50%" y="-50%"  width="200%" height="200%">
              <feDropShadow dx="0" dy="0" stdDeviation="10" flood-color="hsla(180,90%,40%,0.9)" />
          </filter>
      </svg>
  </div>

  </body>

  <script>
    // 计算控制点的坐标
    function computeControlPoint(ps, pe, arc = 0.5) {
	  const deltaX = pe[0] - ps[0];
	  const deltaY = pe[1] - ps[1];
	  const theta = Math.atan(deltaY / deltaX);
	  const len = Math.sqrt((deltaX * deltaX) + (deltaY * deltaY)) / 2 * arc;   
	  const newTheta = theta - Math.PI / 2;    
	  return [
	    (ps[0] + pe[0]) / 2 + len * Math.cos(newTheta),    
	    (ps[1] + pe[1]) / 2 + len * Math.sin(newTheta),    
	  ];
    }
    
    function transPath(point){
        console.log(point['startPoint']);
        let startPoint = point['startPoint'];
        let endPoint = point['endPoint'];
        let controlPoint = point['controlPoint'];
        return `M${startPoint[0]}, ${startPoint[1]} Q${controlPoint[0]},${controlPoint[1]} ${endPoint[0]}, ${endPoint[1]}`;
    }
    
    /**
     * 基本配置 
     */
    const svgWidth = 1300;
    const svgHeight = 600;
    const padding = 30;

    const svg = d3.select(".chart")
        .attr("height", svgHeight)
        .attr("width", svgWidth)
        .style("background","#123456");

    const x0 = padding;
    const y0 = padding;
    const x1 = svgWidth - padding * 2;
    const y1 = svgHeight - padding * 2;
    const projection = d3.geoMercator().fitExtent(
        [
            [x0, y0],
            [x1, y1],
        ], taxi_zones);

    const pathGenerator = d3.geoPath().projection(projection); //配置上投影
    // 定义地理路径生成器
    const mapContainer = svg.append("g"); //添加mapContainer装载地图绘制内容
    // 加载地图内容
    const mapPath = mapContainer.selectAll("path")
        .data(taxi_zones.features) //数据绑定
        .join("path")
        .attr("d", pathGenerator) //绘制path
        .attr("stroke-width", 0.5)
        .attr("stroke", "#2F90A1")
        .attr("fill", "#062031");

    // // 地图缩放
    // function zoomed() {
    //     const t = d3.event.transform;
    //     mapContainer.attr("transform", `translate(${t.x}, ${t.y}) scale(${t.k})`); //改变mapContainer的位置及缩放
    // }
    // const zoom = d3.zoom()
    //             .scaleExtent([1, 3])  //设置监听范围
    //             .on("zoom", zoomed);  //设置监听事件
        
    // svg.call(zoom); //应用

    // 计算控制点，并生成线
    var linesGroup = []
    var startpoint = [-73.99929, 40.7247]
    var endpoint = [-73.926060,40.873577]
    var startPoint = projection(startpoint);
    var endPoint = projection(endpoint);
    console.log(startPoint);
    var controlPoint =  computeControlPoint(startPoint, endPoint, 0.5);
    linesGroup.push({
        startPoint,
        endPoint,
        controlPoint: computeControlPoint(startPoint, endPoint, 0.5),
    });

    var startpoint = [-73.949321, 40.788420]
    var endpoint = [-73.996013,40.719760]
    var startPoint = projection(startpoint);
    var endPoint = projection(endpoint);
    var controlPoint =  computeControlPoint(startPoint, endPoint, 0.5);
    linesGroup.push({
        startPoint,
        endPoint,
        controlPoint: computeControlPoint(startPoint, endPoint, 0.5),
    });

    const animate = () => {
        svg.select('.flyline').remove()
        const flylines = svg.append('g').attr('class', 'flyline');
        for (let i = 0; i < linesGroup.length; i += 1){
            flylines
            .append('path')
            .attr('fill', 'none')
            .attr('stroke', 'none')
            .attr('d', transPath(linesGroup[i]))
            .attr('id', `flyline${i}`)

            flylines.append("circle")
            .attr('filter', `url(#inLight)`)
            .attr('stroke', '#82f939')
            .attr('fill', '#d9f939')
            .attr( 'cx' , linesGroup[i]['startPoint'][0])
            .attr( 'cy' , linesGroup[i]['startPoint'][1])
            .attr( 'r' , 2)
            .transition() //转场效果
            .duration( 500 ) //动画转场时间2秒
            .remove()

            flylines.append('path')
            .attr('stroke', '#19D0DC')
            .attr('fill', 'none')
            .attr('id', `flyline${i}`)
            .attr('stroke-width', '1px')
            .attr('mask', `url(#Mask${i})`)
            .transition()
            .duration(3000)
            .attrTween('d', function(d) {
                const $path = d3.select(`#flyline${i}`).node();
                const len = $path.getTotalLength();
                const coord = $path.getAttribute('d').replace(/(M|Q)/g, '').match(/((\d|\.)+)/g);
                var x1 = +coord[0], y1 = +coord[1], // 起点
                    x2 = +coord[2], y2 = +coord[3], // 控制点
                    x3 = +coord[4], y3 = +coord[5]; // 终点
                return function(t) {
                const p = $path.getPointAtLength(t * len) ; 
                const x = (1 - t) * x1 + t * x2;
                const y = (1 - t) * y1 + t * y2;
                d3.select(`#circle${i}`).attr('cx', p.x).attr('cy', p.y);
                
                // 到达终点后，触发
                if (Math.abs(p.x-x3) <= 0.0001 && Math.abs(p.y-y3) <= 0.0001){
                    svg.append("circle")
                    .attr('stroke', '#82f939')
                    .attr('fill', '#044B9466')
                    .attr( 'cx' , linesGroup[i]['endPoint'][0])
                    .attr( 'cy' , linesGroup[i]['endPoint'][1]) //滑鼠y坐标
                    .attr( 'r' , 1e-6 ) //(0.000001 ,科学计算法)
                    .style('stroke' , 10) //(i = (i+1) % 360)取余数 		
                    .style('stroke-opacity', 1 ) //一开始是不透明 		
                    .transition() //转场效果
                    .duration( 1500 ) //动画转场时间2秒
                    .ease( Math .sqrt) //取得平方根，不懂在这边有什么意义
                    .attr( 'r' , 8) //不断放大
                    .style( 'stroke-opacity' , 1e-6 )
                    .remove()
                }


                return `M${x1}, ${y1} Q${x},${y} ${p.x}, ${p.y}`
                }
            })
            .remove(
                // svg.append("circle")
                // .attr('stroke', '#daf872')
                // .attr('fill', '#044B9466')
                // .attr( 'cx' , linesGroup[i]['endPoint'][0])
                // .attr( 'cy' , linesGroup[i]['endPoint'][1]) //滑鼠y坐标
                // .attr( 'r' , 1e-6 ) //(0.000001 ,科学计算法)
                // .style('stroke' , 10) //(i = (i+1) % 360)取余数 		
                // .style('stroke-opacity', 1 ) //一开始是不透明 		
                // .transition() //转场效果
                // .duration( 2000 ) //动画转场时间2秒
                // .ease( Math .sqrt) //取得平方根，不懂在这边有什么意义
                // .attr( 'r' , 100) //不断放大
                // .style( 'stroke-opacity' , 1e-6 )
                // .remove()
            );
        }
    }
    animate()
    setInterval(animate, 3200)
    //`M${x1}, ${y1} Q${x},${y} ${p.x}, ${p.y}`

</script>

</html>
